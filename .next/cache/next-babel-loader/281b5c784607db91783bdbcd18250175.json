{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport zango from \"zangodb\"; // TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString(); // Check if DB for current URL exists\n\n  const dbCheck = await window.indexedDB.databases().then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url)); // If DB existis, increment version in order to add a new collection\n\n  if (typeof dbCheck != \"undefined\" && dbCheck.name === url && dbCheck.version > 0) v = dbCheck.version + 1; // Modify data when storing scan data. If storing metadata, ignore this block\n\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length) return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  } // Define collections without indexes.\n\n\n  const db = new zango.Db(url, v, [collName]);\n  const collection = db.collection(collName);\n  collection.insert(data).then(() => {\n    actions.addInfoEvent(`${meta ? \"Metadata\" : \"Scan data\"} successfully ${meta ? \"stored.\" : \"processed.\"}.`);\n    db.close();\n  }).catch(error => {\n    actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n    console.error(error);\n    db.close();\n  });\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n  });\n};\nexport const getDbNames = async () => window.indexedDB.databases().then(res => res.map(db => db.name));\nexport const getScannedMeta = async () => {\n  try {\n    const dbNames = await getDbNames();\n    const meta = await Promise.all(dbNames.map(dbName => new Promise((resolve, reject) => {\n      const db = new zango.Db(dbName, [\"metadata\"]);\n      let col = db.collection(\"metadata\");\n      col.findOne().then(res => resolve(_objectSpread({\n        dbName\n      }, res))).catch(err => reject(err));\n    })));\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return {\n      ok: false\n    };\n  }\n};\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return {\n      ok: true,\n      data\n    };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return {\n      ok: false,\n      data: error\n    };\n  }\n};","map":{"version":3,"sources":["/home/angelovski/Documents/Projects/dccscanner/web/src/lib/helpers/processDb.js"],"names":["zango","makeStoreData","url","actions","meta","data","v","collName","Date","getTime","toString","dbCheck","window","indexedDB","databases","then","dbs","Array","isArray","find","db","name","version","filter","item","Object","keys","length","addInfoEvent","Db","collection","insert","close","catch","error","addErrorEvent","message","console","on","warn","getDbNames","res","map","getScannedMeta","dbNames","Promise","all","dbName","resolve","reject","col","findOne","err","ok","getStoresNames","open","_idb","objectStoreNames","getStoreData","store","toArray"],"mappings":"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","sourcesContent":["import zango from \"zangodb\";\n\n// TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString();\n\n  // Check if DB for current URL exists\n  const dbCheck = await window.indexedDB\n    .databases()\n    .then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url));\n\n  // If DB existis, increment version in order to add a new collection\n  if (\n    typeof dbCheck != \"undefined\" &&\n    dbCheck.name === url &&\n    dbCheck.version > 0\n  )\n    v = dbCheck.version + 1;\n\n  // Modify data when storing scan data. If storing metadata, ignore this block\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length)\n      return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  }\n\n  // Define collections without indexes.\n  const db = new zango.Db(url, v, [collName]);\n\n  const collection = db.collection(collName);\n\n  collection\n    .insert(data)\n    .then(() => {\n      actions.addInfoEvent(\n        `${meta ? \"Metadata\" : \"Scan data\"} successfully ${\n          meta ? \"stored.\" : \"processed.\"\n        }.`\n      );\n      db.close();\n    })\n    .catch(error => {\n      actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n      console.error(error);\n      db.close();\n    });\n\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n  });\n};\n\nexport const getDbNames = async () =>\n  window.indexedDB.databases().then(res => res.map(db => db.name));\n\nexport const getScannedMeta = async () => {\n  try {\n    const dbNames = await getDbNames();\n\n    const meta = await Promise.all(\n      dbNames.map(\n        dbName =>\n          new Promise((resolve, reject) => {\n            const db = new zango.Db(dbName, [\"metadata\"]);\n            let col = db.collection(\"metadata\");\n            col\n              .findOne()\n              .then(res => resolve({ dbName, ...res }))\n              .catch(err => reject(err));\n          })\n      )\n    );\n\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return { ok: false };\n  }\n};\n\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\n\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return { ok: true, data };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return { ok: false, data: error };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}