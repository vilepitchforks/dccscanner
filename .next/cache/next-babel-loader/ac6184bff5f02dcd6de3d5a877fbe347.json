{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport zango from \"zangodb\"; // TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport var makeStoreData = function makeStoreData(url, actions, meta) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n      var v, collName, dbCheck, db, collection;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              v = 0;\n              collName = meta ? \"metadata\" : new Date().getTime().toString(); // Check if DB for current URL exists\n\n              _context.next = 4;\n              return window.indexedDB.databases().then(function (dbs) {\n                return Array.isArray(dbs) && dbs.find(function (db) {\n                  return db.name === url;\n                });\n              });\n\n            case 4:\n              dbCheck = _context.sent;\n              // If DB existis, increment version in order to add a new collection\n              if (typeof dbCheck != \"undefined\" && dbCheck.name === url && dbCheck.version > 0) v = dbCheck.version + 1; // Modify data when storing scan data. If storing metadata, ignore this block\n\n              if (meta) {\n                _context.next = 10;\n                break;\n              }\n\n              // Get only results with valid DCC objects\n              data = data[url] && data[url].filter(function (item) {\n                return Object.keys(item).length > 1;\n              });\n\n              if (!(typeof data === \"undefined\" || !data.length)) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"return\", actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\"));\n\n            case 10:\n              // Define collections without indexes.\n              db = new zango.Db(url, v, [collName]);\n              collection = db.collection(collName);\n              collection.insert(data).then(function () {\n                actions.addInfoEvent(\"\".concat(meta ? \"Metadata\" : \"Scan data\", \" successfully processed.\"));\n                db.close();\n              })[\"catch\"](function (error) {\n                actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n                console.error(error);\n                db.close();\n              });\n              db.on(\"blocked\", function () {\n                console.warn(\"database version cannot be upgraded\");\n              });\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\nexport var getDbNames = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", window.indexedDB.databases().then(function (res) {\n              return res.map(function (db) {\n                return db.name;\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getDbNames() {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var getScannedMeta = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var dbNames, meta;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return getDbNames();\n\n          case 3:\n            dbNames = _context3.sent;\n            _context3.next = 6;\n            return Promise.all(dbNames.map(function (dbName) {\n              return new Promise(function (resolve, reject) {\n                var db = new zango.Db(dbName, [\"metadata\"]);\n                var col = db.collection(\"metadata\");\n                col.findOne().then(function (res) {\n                  return resolve(_objectSpread({\n                    dbName: dbName\n                  }, res));\n                })[\"catch\"](function (err) {\n                  return reject(err);\n                });\n              });\n            }));\n\n          case 6:\n            meta = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              ok: true,\n              meta: meta\n            });\n\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.warn(\"Error occurred while fetching scanned Metadata: \", _context3.t0);\n            return _context3.abrupt(\"return\", {\n              ok: false\n            });\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 10]]);\n  }));\n\n  return function getScannedMeta() {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var getStoresNames = function getStoresNames(dbName) {\n  var db = new zango.Db(dbName);\n  return new Promise(function (resolve, reject) {\n    db.open(function () {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\nexport var getStoreData = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dbName, store) {\n    var db, col, data;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            db = new zango.Db(dbName, [store]);\n            col = db.collection(store);\n            _context4.next = 5;\n            return col.find().toArray();\n\n          case 5:\n            data = _context4.sent;\n            return _context4.abrupt(\"return\", {\n              ok: true,\n              data: data\n            });\n\n          case 9:\n            _context4.prev = 9;\n            _context4.t0 = _context4[\"catch\"](0);\n            console.warn(\"Error accessing data: \", _context4.t0);\n            return _context4.abrupt(\"return\", {\n              ok: false,\n              data: _context4.t0\n            });\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 9]]);\n  }));\n\n  return function getStoreData(_x2, _x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":{"version":3,"sources":["/home/angelovski/Documents/Projects/dccscanner/web/src/lib/helpers/processDb.js"],"names":["zango","makeStoreData","url","actions","meta","data","v","collName","Date","getTime","toString","window","indexedDB","databases","then","dbs","Array","isArray","find","db","name","dbCheck","version","filter","item","Object","keys","length","addInfoEvent","Db","collection","insert","close","error","addErrorEvent","message","console","on","warn","getDbNames","res","map","getScannedMeta","dbNames","Promise","all","dbName","resolve","reject","col","findOne","err","ok","getStoresNames","open","_idb","objectStoreNames","getStoreData","store","toArray"],"mappings":"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","sourcesContent":["import zango from \"zangodb\";\n\n// TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString();\n\n  // Check if DB for current URL exists\n  const dbCheck = await window.indexedDB\n    .databases()\n    .then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url));\n\n  // If DB existis, increment version in order to add a new collection\n  if (\n    typeof dbCheck != \"undefined\" &&\n    dbCheck.name === url &&\n    dbCheck.version > 0\n  )\n    v = dbCheck.version + 1;\n\n  // Modify data when storing scan data. If storing metadata, ignore this block\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length)\n      return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  }\n\n  // Define collections without indexes.\n  const db = new zango.Db(url, v, [collName]);\n\n  const collection = db.collection(collName);\n\n  collection\n    .insert(data)\n    .then(() => {\n      actions.addInfoEvent(\n        `${meta ? \"Metadata\" : \"Scan data\"} successfully processed.`\n      );\n      db.close();\n    })\n    .catch(error => {\n      actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n      console.error(error);\n      db.close();\n    });\n\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n  });\n};\n\nexport const getDbNames = async () =>\n  window.indexedDB.databases().then(res => res.map(db => db.name));\n\nexport const getScannedMeta = async () => {\n  try {\n    const dbNames = await getDbNames();\n\n    const meta = await Promise.all(\n      dbNames.map(\n        dbName =>\n          new Promise((resolve, reject) => {\n            const db = new zango.Db(dbName, [\"metadata\"]);\n            let col = db.collection(\"metadata\");\n            col\n              .findOne()\n              .then(res => resolve({ dbName, ...res }))\n              .catch(err => reject(err));\n          })\n      )\n    );\n\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return { ok: false };\n  }\n};\n\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\n\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return { ok: true, data };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return { ok: false, data: error };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}