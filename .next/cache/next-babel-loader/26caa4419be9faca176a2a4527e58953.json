{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport zango from \"zangodb\";\nimport { useStoreActions } from \"easy-peasy\"; // TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nconst {\n  setScanCompleted\n} = useStoreActions(actions => actions);\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString(); // Check if DB for current URL exists\n\n  const dbCheck = await window.indexedDB.databases().then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url)); // If DB existis, increment version in order to add a new collection\n\n  if (typeof dbCheck != \"undefined\" && dbCheck.name === url && dbCheck.version > 0) v = dbCheck.version + 1; // Modify data when storing scan data. If storing metadata, ignore this block\n\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length) return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  } // Define collections without indexes.\n\n\n  const db = new zango.Db(url, v, [collName]);\n  const collection = db.collection(collName);\n  collection.insert(data).then(() => {\n    actions.addInfoEvent(`${meta ? \"Metadata\" : \"Scan data\"} successfully processed.`);\n    db.close();\n  }).catch(error => {\n    actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n    console.error(error);\n    db.close();\n  });\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n  });\n};\nexport const getDbNames = async () => window.indexedDB.databases().then(res => res.map(db => db.name));\nexport const getScannedMeta = async () => {\n  console.log(\"typeof setScanCompleted\", typeof setScanCompleted);\n\n  try {\n    const dbNames = await getDbNames();\n    const meta = await Promise.all(dbNames.map(dbName => new Promise((resolve, reject) => {\n      const db = new zango.Db(dbName, [\"metadata\"]);\n      let col = db.collection(\"metadata\");\n      col.findOne().then(res => resolve(_objectSpread({\n        dbName\n      }, res))).catch(err => reject(err));\n    })));\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return {\n      ok: false\n    };\n  }\n};\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return {\n      ok: true,\n      data\n    };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return {\n      ok: false,\n      data: error\n    };\n  }\n};","map":{"version":3,"sources":["/home/angelovski/Documents/Projects/dccscanner/web/src/lib/helpers/processDb.js"],"names":["zango","useStoreActions","setScanCompleted","actions","makeStoreData","url","meta","data","v","collName","Date","getTime","toString","dbCheck","window","indexedDB","databases","then","dbs","Array","isArray","find","db","name","version","filter","item","Object","keys","length","addInfoEvent","Db","collection","insert","close","catch","error","addErrorEvent","message","console","on","warn","getDbNames","res","map","getScannedMeta","log","dbNames","Promise","all","dbName","resolve","reject","col","findOne","err","ok","getStoresNames","open","_idb","objectStoreNames","getStoreData","store","toArray"],"mappings":"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","sourcesContent":["import zango from \"zangodb\";\nimport { useStoreActions } from \"easy-peasy\";\n\n// TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nconst { setScanCompleted } = useStoreActions(actions => actions);\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString();\n\n  // Check if DB for current URL exists\n  const dbCheck = await window.indexedDB\n    .databases()\n    .then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url));\n\n  // If DB existis, increment version in order to add a new collection\n  if (\n    typeof dbCheck != \"undefined\" &&\n    dbCheck.name === url &&\n    dbCheck.version > 0\n  )\n    v = dbCheck.version + 1;\n\n  // Modify data when storing scan data. If storing metadata, ignore this block\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length)\n      return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  }\n\n  // Define collections without indexes.\n  const db = new zango.Db(url, v, [collName]);\n\n  const collection = db.collection(collName);\n\n  collection\n    .insert(data)\n    .then(() => {\n      actions.addInfoEvent(\n        `${meta ? \"Metadata\" : \"Scan data\"} successfully processed.`\n      );\n      db.close();\n    })\n    .catch(error => {\n      actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n      console.error(error);\n      db.close();\n    });\n\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n  });\n};\n\nexport const getDbNames = async () =>\n  window.indexedDB.databases().then(res => res.map(db => db.name));\n\nexport const getScannedMeta = async () => {\n  console.log(\"typeof setScanCompleted\", typeof setScanCompleted);\n  try {\n    const dbNames = await getDbNames();\n\n    const meta = await Promise.all(\n      dbNames.map(\n        dbName =>\n          new Promise((resolve, reject) => {\n            const db = new zango.Db(dbName, [\"metadata\"]);\n            let col = db.collection(\"metadata\");\n            col\n              .findOne()\n              .then(res => resolve({ dbName, ...res }))\n              .catch(err => reject(err));\n          })\n      )\n    );\n\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return { ok: false };\n  }\n};\n\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\n\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return { ok: true, data };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return { ok: false, data: error };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}