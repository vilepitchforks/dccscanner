{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport zango from \"zangodb\"; // TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport var makeStoreData = function makeStoreData(url, actions, meta) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n      var v, collName, dbCheck, db, collection;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              v = 0;\n              collName = meta ? \"metadata\" : new Date().getTime().toString(); // Check if DB for current URL exists\n\n              _context.next = 4;\n              return window.indexedDB.databases().then(function (dbs) {\n                return Array.isArray(dbs) && dbs.find(function (db) {\n                  return db.name === url;\n                });\n              });\n\n            case 4:\n              dbCheck = _context.sent;\n              // If DB existis, increment version in order to add a new collection\n              if (typeof dbCheck != \"undefined\" && dbCheck.name === url && dbCheck.version > 0) v = dbCheck.version + 1; // Modify data when storing scan data. If storing metadata, ignore this block\n\n              if (meta) {\n                _context.next = 10;\n                break;\n              }\n\n              // Get only results with valid DCC objects\n              data = data[url] && data[url].filter(function (item) {\n                return Object.keys(item).length > 1;\n              });\n\n              if (!(typeof data === \"undefined\" || !data.length)) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"return\", actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\"));\n\n            case 10:\n              // Define collections without indexes.\n              db = new zango.Db(url, v, [collName]);\n              collection = db.collection(collName);\n              collection.insert(data).then(function () {\n                actions.addInfoEvent(\"\".concat(meta ? \"Metadata\" : \"Scan data\", \" successfully processed.\"));\n                db.close();\n              })[\"catch\"](function (error) {\n                actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n                console.error(error);\n                db.close();\n              });\n              db.on(\"blocked\", function () {\n                console.warn(\"database version cannot be upgraded\");\n              });\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};\nexport var getDbNames = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", window.indexedDB.databases().then(function (res) {\n              return res.map(function (db) {\n                return db.name;\n              });\n            }));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getDbNames() {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var getScannedMeta = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var dbNames, meta;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.prev = 0;\n            _context3.next = 3;\n            return getDbNames();\n\n          case 3:\n            dbNames = _context3.sent;\n            _context3.next = 6;\n            return Promise.all(dbNames.map(function (dbName) {\n              return new Promise(function (resolve, reject) {\n                var db = new zango.Db(dbName, [\"metadata\"]);\n                var col = db.collection(\"metadata\");\n                col.findOne().then(function (res) {\n                  return resolve(_objectSpread({\n                    dbName: dbName\n                  }, res));\n                })[\"catch\"](function (err) {\n                  return reject(err);\n                });\n              });\n            }));\n\n          case 6:\n            meta = _context3.sent;\n            return _context3.abrupt(\"return\", {\n              ok: true,\n              meta: meta\n            });\n\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3[\"catch\"](0);\n            console.warn(\"Error occurred while fetching scanned Metadata: \", _context3.t0);\n            return _context3.abrupt(\"return\", {\n              ok: false\n            });\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[0, 10]]);\n  }));\n\n  return function getScannedMeta() {\n    return _ref3.apply(this, arguments);\n  };\n}();\nexport var getStoresNames = function getStoresNames(dbName) {\n  var db = new zango.Db(dbName);\n  return new Promise(function (resolve, reject) {\n    db.open(function () {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\nexport var getStoreData = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(dbName, store) {\n    var db, col, data;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            db = new zango.Db(dbName, [store]);\n            col = db.collection(store);\n            _context4.next = 5;\n            return col.find().toArray();\n\n          case 5:\n            data = _context4.sent;\n            return _context4.abrupt(\"return\", {\n              ok: true,\n              data: data\n            });\n\n          case 9:\n            _context4.prev = 9;\n            _context4.t0 = _context4[\"catch\"](0);\n            console.warn(\"Error accessing data: \", _context4.t0);\n            return _context4.abrupt(\"return\", {\n              ok: false,\n              data: _context4.t0\n            });\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 9]]);\n  }));\n\n  return function getStoreData(_x2, _x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"module"}