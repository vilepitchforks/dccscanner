{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport zango from \"zangodb\"; // TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString(); // Check if DB for current URL exists\n\n  const dbCheck = await window.indexedDB.databases().then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url)); // If DB existis, increment version in order to add a new collection\n\n  if (typeof dbCheck != \"undefined\" && dbCheck.name === url && dbCheck.version > 0) v = dbCheck.version + 1; // Modify data when storing scan data. If storing metadata, ignore this block\n\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n\n    if (typeof data === \"undefined\" || !data.length) {\n      actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n      actions.setProcessInProgress(false);\n      return;\n    }\n  } // Define collections without indexes.\n\n\n  const db = new zango.Db(url, v, [collName]);\n  const collection = db.collection(collName);\n  const successMsg = meta ? `Metadata for ${url} successfully stored.` : `Scan data for ${url} successfully processed.`;\n  collection.insert(data).then(() => {\n    actions.addInfoEvent(successMsg); // Completes the check switch for the entire process from starting scan to the storing of data in db:\n\n    !meta && actions.setProcessInProgress(false);\n    db.close();\n  }).catch(error => {\n    actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n    console.error(error); // Completes the check switch for the entire process from starting scan to the storing of data in db:\n\n    !meta && actions.setProcessInProgress(false);\n    db.close();\n  });\n  db.on(\"blocked\", () => {\n    console.warn(`Database blocked event fired with details: ${meta ? \"Metadata\" : \"Scan data\"} store attempt for url ${url}`);\n    actions.addInfoEvent(`We are experiencing some issues with ${meta ? \"Metadata\" : \"Scan data\"} processing for ${url}.\\nPlease expect some delays or reload the page and try again.`);\n    db.close();\n  });\n};\nexport const getDbNames = async () => window.indexedDB.databases().then(res => res.map(db => db.name));\nexport const getAllMeta = async () => {\n  try {\n    const dbNames = await getDbNames();\n    const meta = await Promise.all(dbNames.map(dbName => new Promise((resolve, reject) => {\n      const db = new zango.Db(dbName, [\"metadata\"]);\n      let col = db.collection(\"metadata\");\n      col.findOne().then(res => resolve((() => {\n        db.close();\n        return _objectSpread({\n          dbName\n        }, res);\n      })())).catch(err => reject((() => {\n        db.close();\n        return err;\n      })()));\n    })));\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return {\n      ok: false\n    };\n  }\n};\nexport const getSingleMeta = async dbName => {\n  try {\n    const db = new zango.Db(dbName, [\"metadata\"]);\n    let col = db.collection(\"metadata\");\n    const data = await col.findOne();\n    return {\n      ok: true,\n      data\n    };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return {\n      ok: false,\n      data: error\n    };\n  }\n};\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return {\n      ok: true,\n      data\n    };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return {\n      ok: false,\n      data: error\n    };\n  }\n};\nexport const dropDb = async dbName => {\n  try {\n    const db = new zango.Db(dbName);\n    db.drop();\n    return true;\n  } catch (error) {\n    console.warn(\"Error dropping db for: \", dbName, error);\n    return false;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}