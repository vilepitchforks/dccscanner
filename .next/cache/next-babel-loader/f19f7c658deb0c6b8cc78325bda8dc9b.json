{"ast":null,"code":"import { jsxs as _jsxs } from \"react/jsx-runtime\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useEffect, useState } from \"react\";\nimport { useStoreActions, useStoreState } from \"easy-peasy\";\nimport NewScanForm from \"../NewScanForm/NewScanForm.js\";\nimport WebCard from \"../WebCard/WebCard.js\";\nimport NewScanInit from \"../NewScanInit/NewScanInit.js\";\nimport ModalBackground from \"../ModalBackground/ModalBackground.js\";\nimport css from \"./NewScanModal.module.css\";\nimport { slugDriver } from \"../../lib/drivers/restDrivers\";\nimport { urlRgx } from \"../../lib/helpers/regex\";\nimport { withoutCreds } from \"../../lib/helpers/withoutCreds.js\";\n\nconst NewScanModal = ({\n  isNew,\n  setIsNew,\n  setNewScan\n}) => {\n  const {\n    0: loading,\n    1: setLoading\n  } = useState(false);\n  const {\n    0: url,\n    1: setUrl\n  } = useState(\"\");\n  const {\n    0: slugs,\n    1: setSlugs\n  } = useState([]);\n  const {\n    scanCtgs,\n    db\n  } = useStoreState(state => state);\n  const actions = useStoreActions(actions => actions);\n\n  const getMetaFromDb = async () => {\n    setLoading(true); // Check if metadata exists in local db. typeof meta<{res}:Object || undefined>\n\n    const meta = await db.collection(\"metadata\").findOne({\n      scannedUrl: url\n    });\n\n    if (meta) {\n      actions.addInfoEvent(`Metadata for ${url} successfully fetched.`);\n      setLoading(false);\n      return {\n        ok: true,\n        meta\n      };\n    } else {\n      setLoading(false);\n      return {\n        ok: false,\n        meta: {}\n      };\n    }\n  };\n\n  const getMetaFromWebsite = async () => {\n    setLoading(true);\n    let meta = {},\n        isMetaAvailable = false,\n        isMetaStored = false; // If website does not exist in local db, fetch metadata\n\n    const fetchedMeta = await slugDriver({\n      query: \"url=\" + url\n    });\n    if (fetchedMeta && fetchedMeta.metadata) isMetaAvailable = true; // Website details are fetched and metadata exists\n\n    if (isMetaAvailable) {\n      meta = _objectSpread({\n        scannedUrl: withoutCreds(url),\n        slugs: fetchedMeta.slugs\n      }, fetchedMeta.metadata);\n    }\n\n    if (isMetaAvailable) {\n      // Store website metadata and slugs to local db\n      await db.collection(\"metadata\").insert(meta, () => {\n        actions.addInfoEvent(`Metadata for ${withoutCreds(url)} successfully stored.`);\n        isMetaStored = true;\n      });\n    }\n\n    if (isMetaStored) {\n      setLoading(false);\n      return {\n        ok: true,\n        meta\n      };\n    } else {\n      setLoading(false);\n      return {\n        ok: false,\n        meta\n      };\n    }\n  };\n\n  const getMeta = async () => {\n    let data = await getMetaFromDb();\n    if (data.ok) return data.meta;\n    data = await getMetaFromWebsite();\n    if (data.ok) return data.meta;\n    return false;\n  };\n\n  const handleSlugs = async () => {\n    if (!urlRgx.test(url)) return; // setIsNew(false) Removes the default \"New DCC scan\" text\n\n    setIsNew(false);\n    const meta = await getMeta();\n\n    if (meta) {\n      actions.setMetadata(meta); // setSlugs(meta.slugs);\n      // return actions.setScanUrl(url);\n\n      return setSlugs(meta.slugs); // return actions.setScanUrl(url);\n    } else {\n      // If fetching metadata fails, reset the default \"New DCC scan\" details and remove url from state\n      setIsNew(true);\n      setUrl(\"\");\n    }\n\n    return;\n  }; // Cleanup function, resets all url data each time Modal component unmounts\n\n\n  useEffect(() => () => setIsNew(true), []);\n  return /*#__PURE__*/_jsx(ModalBackground, {\n    trigger: setNewScan,\n    children: /*#__PURE__*/_jsxs(\"div\", {\n      className: css.modal,\n      children: [/*#__PURE__*/_jsxs(\"div\", {\n        className: \"row flex\",\n        children: [/*#__PURE__*/_jsx(\"div\", {\n          className: \"three columns\",\n          children: /*#__PURE__*/_jsx(NewScanForm, {\n            loading: loading,\n            url: url,\n            setUrl: setUrl,\n            slugs: slugs,\n            handleSlugs: handleSlugs\n          })\n        }), /*#__PURE__*/_jsx(WebCard, {\n          loading: loading,\n          isNew: isNew\n        })]\n      }), /*#__PURE__*/_jsx(\"div\", {\n        className: \"row\",\n        children: scanCtgs && /*#__PURE__*/_jsx(NewScanInit, {\n          url: url,\n          setUrl: setUrl,\n          setNewScan: setNewScan\n        })\n      })]\n    })\n  });\n};\n\nexport default NewScanModal;","map":null,"metadata":{},"sourceType":"module"}