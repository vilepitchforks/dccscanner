{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport xlsx from \"xlsx\";\nimport { formatTs } from \"../../lib/helpers/formatTimestamps.js\";\nimport { localeRgx } from \"../../lib/helpers/regex.js\";\nexport const handleDownloadXlsAll = async (db, scannedUrl) => {\n  const title = makeReportName(scannedUrl, \"xlsx\");\n\n  try {\n    // Fetch all data for one website from db\n    let websiteData = await db.col(\"dccdata\").findAsArray({\n      url: scannedUrl\n    }, {\n      _id: 0,\n      url: 0\n    });\n    websiteData = websiteData // Where category field is an array of objects, extract only the \"name\" value\n    .map(item => {\n      if (Array.isArray(item.categoryPath)) item.categoryPath = item.categoryPath.reduce((acc, curr) => {\n        if (curr.Name) return acc = curr.Name;\n      }, \"\");\n      return item;\n    });\n    const tsSet = new Set(websiteData.map(d => d.timestamp));\n    const timestamps = Array.from(tsSet).reverse(); // Group data by timestamp\n\n    const workbookData = timestamps.map(tStamp => websiteData.filter(row => row.timestamp === tStamp));\n    const workbook = xlsx.utils.book_new();\n    workbookData.forEach((sheet, i) => {\n      sheet.forEach(row => delete row.timestamp);\n      const wsName = formatTs(timestamps[i]);\n      const worksheet = xlsx.utils.json_to_sheet(sheet);\n      xlsx.utils.book_append_sheet(workbook, worksheet, wsName);\n    });\n    xlsx.writeFile(workbook, title);\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\nexport const handleDownloadXls = async (scannedUrl, reportData) => {\n  // Remove timestamps\n  reportData = reportData.map(row => {\n    const {\n      timestamp\n    } = row,\n          remainingKeys = _objectWithoutProperties(row, [\"timestamp\"]);\n\n    return remainingKeys;\n  });\n  const title = makeReportName(scannedUrl, \"xlsx\");\n\n  try {\n    const workbook = xlsx.utils.book_new();\n    const wsName = formatTs(new Date().getTime());\n    const worksheet = xlsx.utils.json_to_sheet(reportData);\n    xlsx.utils.book_append_sheet(workbook, worksheet, wsName);\n    xlsx.writeFile(workbook, title);\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\nexport const handleDownloadCsvBlob = (scannedUrl, reportData) => {\n  // Remove timestamps\n  reportData = reportData.map(row => {\n    const {\n      timestamp\n    } = row,\n          remainingKeys = _objectWithoutProperties(row, [\"timestamp\"]);\n\n    return remainingKeys;\n  });\n  const reportTitle = makeReportName(scannedUrl, \"csv\");\n\n  try {\n    const worksheet = xlsx.utils.json_to_sheet(reportData);\n    const csv = xlsx.utils.sheet_to_csv(worksheet);\n    window.URL = window.URL || window.webkiURL;\n    const blob = new Blob([csv]);\n    const blobURL = window.URL.createObjectURL(blob);\n    return {\n      reportTitle,\n      blobURL\n    };\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\nexport const handleDownloadJsonBlob = (scannedUrl, reportData) => {\n  // Remove timestamps\n  reportData = reportData.map(row => {\n    const {\n      timestamp\n    } = row,\n          remainingKeys = _objectWithoutProperties(row, [\"timestamp\"]);\n\n    return remainingKeys;\n  });\n  const reportTitle = makeReportName(scannedUrl, \"json\");\n\n  try {\n    window.URL = window.URL || window.webkiURL;\n    const blob = new Blob([JSON.stringify(reportData, null, 2)]);\n    const blobURL = window.URL.createObjectURL(blob);\n    return {\n      reportTitle,\n      blobURL\n    };\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\n\nconst makeReportName = (scannedUrl, extension) => {\n  let urlRN = scannedUrl.replace(/http(|s)\\:\\/\\//, \"\").split(localeRgx)[0];\n  if (urlRN.slice(-1) === \"/\") urlRN = urlRN.slice(0, urlRN.length - 1);\n  return `bvDCC_extract_${urlRN}_${new Date().getTime()}.${extension}`;\n};","map":{"version":3,"sources":["/home/angelovski/Documents/Projects/dccscanner/web/src/components/DownloadIcons/DownloadIcons.helper.js"],"names":["xlsx","formatTs","localeRgx","handleDownloadXlsAll","db","scannedUrl","title","makeReportName","websiteData","col","findAsArray","url","_id","map","item","Array","isArray","categoryPath","reduce","acc","curr","Name","tsSet","Set","d","timestamp","timestamps","from","reverse","workbookData","tStamp","filter","row","workbook","utils","book_new","forEach","sheet","i","wsName","worksheet","json_to_sheet","book_append_sheet","writeFile","error","console","warn","handleDownloadXls","reportData","remainingKeys","Date","getTime","handleDownloadCsvBlob","reportTitle","csv","sheet_to_csv","window","URL","webkiURL","blob","Blob","blobURL","createObjectURL","handleDownloadJsonBlob","JSON","stringify","extension","urlRN","replace","split","slice","length"],"mappings":";;;;AAAA,OAAOA,IAAP,MAAiB,MAAjB;AAEA,SAASC,QAAT,QAAyB,uCAAzB;AACA,SAASC,SAAT,QAA0B,4BAA1B;AAEA,OAAO,MAAMC,oBAAoB,GAAG,OAAOC,EAAP,EAAWC,UAAX,KAA0B;AAC5D,QAAMC,KAAK,GAAGC,cAAc,CAACF,UAAD,EAAa,MAAb,CAA5B;;AAEA,MAAI;AACF;AACA,QAAIG,WAAW,GAAG,MAAMJ,EAAE,CACvBK,GADqB,CACjB,SADiB,EAErBC,WAFqB,CAET;AAAEC,MAAAA,GAAG,EAAEN;AAAP,KAFS,EAEY;AAAEO,MAAAA,GAAG,EAAE,CAAP;AAAUD,MAAAA,GAAG,EAAE;AAAf,KAFZ,CAAxB;AAIAH,IAAAA,WAAW,GAAGA,WAAW,CACvB;AADuB,KAEtBK,GAFW,CAEPC,IAAI,IAAI;AACX,UAAIC,KAAK,CAACC,OAAN,CAAcF,IAAI,CAACG,YAAnB,CAAJ,EACEH,IAAI,CAACG,YAAL,GAAoBH,IAAI,CAACG,YAAL,CAAkBC,MAAlB,CAAyB,CAACC,GAAD,EAAMC,IAAN,KAAe;AAC1D,YAAIA,IAAI,CAACC,IAAT,EAAe,OAAQF,GAAG,GAAGC,IAAI,CAACC,IAAnB;AAChB,OAFmB,EAEjB,EAFiB,CAApB;AAGF,aAAOP,IAAP;AACD,KARW,CAAd;AAUA,UAAMQ,KAAK,GAAG,IAAIC,GAAJ,CAAQf,WAAW,CAACK,GAAZ,CAAgBW,CAAC,IAAIA,CAAC,CAACC,SAAvB,CAAR,CAAd;AACA,UAAMC,UAAU,GAAGX,KAAK,CAACY,IAAN,CAAWL,KAAX,EAAkBM,OAAlB,EAAnB,CAjBE,CAmBF;;AACA,UAAMC,YAAY,GAAGH,UAAU,CAACb,GAAX,CAAeiB,MAAM,IACxCtB,WAAW,CAACuB,MAAZ,CAAmBC,GAAG,IAAIA,GAAG,CAACP,SAAJ,KAAkBK,MAA5C,CADmB,CAArB;AAIA,UAAMG,QAAQ,GAAGjC,IAAI,CAACkC,KAAL,CAAWC,QAAX,EAAjB;AAEAN,IAAAA,YAAY,CAACO,OAAb,CAAqB,CAACC,KAAD,EAAQC,CAAR,KAAc;AACjCD,MAAAA,KAAK,CAACD,OAAN,CAAcJ,GAAG,IAAI,OAAOA,GAAG,CAACP,SAAhC;AAEA,YAAMc,MAAM,GAAGtC,QAAQ,CAACyB,UAAU,CAACY,CAAD,CAAX,CAAvB;AAEA,YAAME,SAAS,GAAGxC,IAAI,CAACkC,KAAL,CAAWO,aAAX,CAAyBJ,KAAzB,CAAlB;AACArC,MAAAA,IAAI,CAACkC,KAAL,CAAWQ,iBAAX,CAA6BT,QAA7B,EAAuCO,SAAvC,EAAkDD,MAAlD;AACD,KAPD;AASAvC,IAAAA,IAAI,CAAC2C,SAAL,CAAeV,QAAf,EAAyB3B,KAAzB;AACD,GApCD,CAoCE,OAAOsC,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACC,IAAR,CAAa,8CAAb,EAA6DF,KAA7D;AACD;AACF,CA1CM;AA4CP,OAAO,MAAMG,iBAAiB,GAAG,OAAO1C,UAAP,EAAmB2C,UAAnB,KAAkC;AACjE;AACAA,EAAAA,UAAU,GAAGA,UAAU,CAACnC,GAAX,CAAemB,GAAG,IAAI;AACjC,UAAM;AAAEP,MAAAA;AAAF,QAAkCO,GAAxC;AAAA,UAAsBiB,aAAtB,4BAAwCjB,GAAxC;;AACA,WAAOiB,aAAP;AACD,GAHY,CAAb;AAKA,QAAM3C,KAAK,GAAGC,cAAc,CAACF,UAAD,EAAa,MAAb,CAA5B;;AAEA,MAAI;AACF,UAAM4B,QAAQ,GAAGjC,IAAI,CAACkC,KAAL,CAAWC,QAAX,EAAjB;AAEA,UAAMI,MAAM,GAAGtC,QAAQ,CAAC,IAAIiD,IAAJ,GAAWC,OAAX,EAAD,CAAvB;AAEA,UAAMX,SAAS,GAAGxC,IAAI,CAACkC,KAAL,CAAWO,aAAX,CAAyBO,UAAzB,CAAlB;AAEAhD,IAAAA,IAAI,CAACkC,KAAL,CAAWQ,iBAAX,CAA6BT,QAA7B,EAAuCO,SAAvC,EAAkDD,MAAlD;AAEAvC,IAAAA,IAAI,CAAC2C,SAAL,CAAeV,QAAf,EAAyB3B,KAAzB;AACD,GAVD,CAUE,OAAOsC,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACC,IAAR,CAAa,8CAAb,EAA6DF,KAA7D;AACD;AACF,CAtBM;AAwBP,OAAO,MAAMQ,qBAAqB,GAAG,CAAC/C,UAAD,EAAa2C,UAAb,KAA4B;AAC/D;AACAA,EAAAA,UAAU,GAAGA,UAAU,CAACnC,GAAX,CAAemB,GAAG,IAAI;AACjC,UAAM;AAAEP,MAAAA;AAAF,QAAkCO,GAAxC;AAAA,UAAsBiB,aAAtB,4BAAwCjB,GAAxC;;AACA,WAAOiB,aAAP;AACD,GAHY,CAAb;AAKA,QAAMI,WAAW,GAAG9C,cAAc,CAACF,UAAD,EAAa,KAAb,CAAlC;;AAEA,MAAI;AACF,UAAMmC,SAAS,GAAGxC,IAAI,CAACkC,KAAL,CAAWO,aAAX,CAAyBO,UAAzB,CAAlB;AAEA,UAAMM,GAAG,GAAGtD,IAAI,CAACkC,KAAL,CAAWqB,YAAX,CAAwBf,SAAxB,CAAZ;AAEAgB,IAAAA,MAAM,CAACC,GAAP,GAAaD,MAAM,CAACC,GAAP,IAAcD,MAAM,CAACE,QAAlC;AACA,UAAMC,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACN,GAAD,CAAT,CAAb;AACA,UAAMO,OAAO,GAAGL,MAAM,CAACC,GAAP,CAAWK,eAAX,CAA2BH,IAA3B,CAAhB;AAEA,WAAO;AAAEN,MAAAA,WAAF;AAAeQ,MAAAA;AAAf,KAAP;AACD,GAVD,CAUE,OAAOjB,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACC,IAAR,CAAa,8CAAb,EAA6DF,KAA7D;AACD;AACF,CAtBM;AAwBP,OAAO,MAAMmB,sBAAsB,GAAG,CAAC1D,UAAD,EAAa2C,UAAb,KAA4B;AAChE;AACAA,EAAAA,UAAU,GAAGA,UAAU,CAACnC,GAAX,CAAemB,GAAG,IAAI;AACjC,UAAM;AAAEP,MAAAA;AAAF,QAAkCO,GAAxC;AAAA,UAAsBiB,aAAtB,4BAAwCjB,GAAxC;;AACA,WAAOiB,aAAP;AACD,GAHY,CAAb;AAKA,QAAMI,WAAW,GAAG9C,cAAc,CAACF,UAAD,EAAa,MAAb,CAAlC;;AAEA,MAAI;AACFmD,IAAAA,MAAM,CAACC,GAAP,GAAaD,MAAM,CAACC,GAAP,IAAcD,MAAM,CAACE,QAAlC;AACA,UAAMC,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACI,IAAI,CAACC,SAAL,CAAejB,UAAf,EAA2B,IAA3B,EAAiC,CAAjC,CAAD,CAAT,CAAb;AACA,UAAMa,OAAO,GAAGL,MAAM,CAACC,GAAP,CAAWK,eAAX,CAA2BH,IAA3B,CAAhB;AAEA,WAAO;AAAEN,MAAAA,WAAF;AAAeQ,MAAAA;AAAf,KAAP;AACD,GAND,CAME,OAAOjB,KAAP,EAAc;AACdC,IAAAA,OAAO,CAACC,IAAR,CAAa,8CAAb,EAA6DF,KAA7D;AACD;AACF,CAlBM;;AAoBP,MAAMrC,cAAc,GAAG,CAACF,UAAD,EAAa6D,SAAb,KAA2B;AAChD,MAAIC,KAAK,GAAG9D,UAAU,CAAC+D,OAAX,CAAmB,gBAAnB,EAAqC,EAArC,EAAyCC,KAAzC,CAA+CnE,SAA/C,EAA0D,CAA1D,CAAZ;AACA,MAAIiE,KAAK,CAACG,KAAN,CAAY,CAAC,CAAb,MAAoB,GAAxB,EAA6BH,KAAK,GAAGA,KAAK,CAACG,KAAN,CAAY,CAAZ,EAAeH,KAAK,CAACI,MAAN,GAAe,CAA9B,CAAR;AAC7B,SAAQ,iBAAgBJ,KAAM,IAAG,IAAIjB,IAAJ,GAAWC,OAAX,EAAqB,IAAGe,SAAU,EAAnE;AACD,CAJD","sourcesContent":["import xlsx from \"xlsx\";\n\nimport { formatTs } from \"../../lib/helpers/formatTimestamps.js\";\nimport { localeRgx } from \"../../lib/helpers/regex.js\";\n\nexport const handleDownloadXlsAll = async (db, scannedUrl) => {\n  const title = makeReportName(scannedUrl, \"xlsx\");\n\n  try {\n    // Fetch all data for one website from db\n    let websiteData = await db\n      .col(\"dccdata\")\n      .findAsArray({ url: scannedUrl }, { _id: 0, url: 0 });\n\n    websiteData = websiteData\n      // Where category field is an array of objects, extract only the \"name\" value\n      .map(item => {\n        if (Array.isArray(item.categoryPath))\n          item.categoryPath = item.categoryPath.reduce((acc, curr) => {\n            if (curr.Name) return (acc = curr.Name);\n          }, \"\");\n        return item;\n      });\n\n    const tsSet = new Set(websiteData.map(d => d.timestamp));\n    const timestamps = Array.from(tsSet).reverse();\n\n    // Group data by timestamp\n    const workbookData = timestamps.map(tStamp =>\n      websiteData.filter(row => row.timestamp === tStamp)\n    );\n\n    const workbook = xlsx.utils.book_new();\n\n    workbookData.forEach((sheet, i) => {\n      sheet.forEach(row => delete row.timestamp);\n\n      const wsName = formatTs(timestamps[i]);\n\n      const worksheet = xlsx.utils.json_to_sheet(sheet);\n      xlsx.utils.book_append_sheet(workbook, worksheet, wsName);\n    });\n\n    xlsx.writeFile(workbook, title);\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\n\nexport const handleDownloadXls = async (scannedUrl, reportData) => {\n  // Remove timestamps\n  reportData = reportData.map(row => {\n    const { timestamp, ...remainingKeys } = row;\n    return remainingKeys;\n  });\n\n  const title = makeReportName(scannedUrl, \"xlsx\");\n\n  try {\n    const workbook = xlsx.utils.book_new();\n\n    const wsName = formatTs(new Date().getTime());\n\n    const worksheet = xlsx.utils.json_to_sheet(reportData);\n\n    xlsx.utils.book_append_sheet(workbook, worksheet, wsName);\n\n    xlsx.writeFile(workbook, title);\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\n\nexport const handleDownloadCsvBlob = (scannedUrl, reportData) => {\n  // Remove timestamps\n  reportData = reportData.map(row => {\n    const { timestamp, ...remainingKeys } = row;\n    return remainingKeys;\n  });\n\n  const reportTitle = makeReportName(scannedUrl, \"csv\");\n\n  try {\n    const worksheet = xlsx.utils.json_to_sheet(reportData);\n\n    const csv = xlsx.utils.sheet_to_csv(worksheet);\n\n    window.URL = window.URL || window.webkiURL;\n    const blob = new Blob([csv]);\n    const blobURL = window.URL.createObjectURL(blob);\n\n    return { reportTitle, blobURL };\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\n\nexport const handleDownloadJsonBlob = (scannedUrl, reportData) => {\n  // Remove timestamps\n  reportData = reportData.map(row => {\n    const { timestamp, ...remainingKeys } = row;\n    return remainingKeys;\n  });\n\n  const reportTitle = makeReportName(scannedUrl, \"json\");\n\n  try {\n    window.URL = window.URL || window.webkiURL;\n    const blob = new Blob([JSON.stringify(reportData, null, 2)]);\n    const blobURL = window.URL.createObjectURL(blob);\n\n    return { reportTitle, blobURL };\n  } catch (error) {\n    console.warn(\"An error occurred while creating the report!\", error);\n  }\n};\n\nconst makeReportName = (scannedUrl, extension) => {\n  let urlRN = scannedUrl.replace(/http(|s)\\:\\/\\//, \"\").split(localeRgx)[0];\n  if (urlRN.slice(-1) === \"/\") urlRN = urlRN.slice(0, urlRN.length - 1);\n  return `bvDCC_extract_${urlRN}_${new Date().getTime()}.${extension}`;\n};\n"]},"metadata":{},"sourceType":"module"}