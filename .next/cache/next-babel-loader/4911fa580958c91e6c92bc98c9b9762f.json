{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport zango from \"zangodb\"; // TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString(); // Check if DB for current URL exists\n\n  const dbCheck = await window.indexedDB.databases().then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url)); // If DB existis, increment version in order to add a new collection\n\n  if (typeof dbCheck != \"undefined\" && dbCheck.name === url && dbCheck.version > 0) v = dbCheck.version + 1; // Modify data when storing scan data. If storing metadata, ignore this block\n\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length) return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  } // Define collections without indexes.\n\n\n  const db = new zango.Db(url, v, [collName]);\n  const collection = db.collection(collName);\n  const successMsg = meta ? \"Metadata successfully stored.\" : \"Scan data successfully processed.\";\n  collection.insert(data).then(() => {\n    actions.addInfoEvent(successMsg); // Completes the check switch for the entire process from starting scan to the storing of data in db:\n\n    !meta && actions.setProcessInProgress(false);\n    db.close();\n  }).catch(error => {\n    actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n    console.error(error); // Completes the check switch for the entire process from starting scan to the storing of data in db:\n\n    !meta && actions.setProcessInProgress(false);\n    db.close();\n  });\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n    db.close();\n  });\n};\nexport const getDbNames = async () => window.indexedDB.databases().then(res => res.map(db => db.name));\nexport const getScannedMeta = async () => {\n  try {\n    const dbNames = await getDbNames();\n    const meta = await Promise.all(dbNames.map(dbName => new Promise((resolve, reject) => {\n      const db = new zango.Db(dbName, [\"metadata\"]);\n      let col = db.collection(\"metadata\");\n      col.findOne().then(res => resolve(_objectSpread({\n        dbName\n      }, res))).catch(err => reject(err));\n    })));\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return {\n      ok: false\n    };\n  }\n};\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return {\n      ok: true,\n      data\n    };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return {\n      ok: false,\n      data: error\n    };\n  }\n};","map":{"version":3,"sources":["/home/angelovski/Documents/Projects/dccscanner/web/src/lib/helpers/processDb.js"],"names":["zango","makeStoreData","url","actions","meta","data","v","collName","Date","getTime","toString","dbCheck","window","indexedDB","databases","then","dbs","Array","isArray","find","db","name","version","filter","item","Object","keys","length","addInfoEvent","Db","collection","successMsg","insert","setProcessInProgress","close","catch","error","addErrorEvent","message","console","on","warn","getDbNames","res","map","getScannedMeta","dbNames","Promise","all","dbName","resolve","reject","col","findOne","err","ok","getStoresNames","open","_idb","objectStoreNames","getStoreData","store","toArray"],"mappings":"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","sourcesContent":["import zango from \"zangodb\";\n\n// TO DO: check if db exists before running scan\n// export const getDbs = async () =>{}\n\n// TO DO: if existing url has been selected, return metadata\n// export const checkMeta = async () =>{}\n\nexport const makeStoreData = (url, actions, meta) => async data => {\n  let v = 0;\n  const collName = meta ? \"metadata\" : new Date().getTime().toString();\n\n  // Check if DB for current URL exists\n  const dbCheck = await window.indexedDB\n    .databases()\n    .then(dbs => Array.isArray(dbs) && dbs.find(db => db.name === url));\n\n  // If DB existis, increment version in order to add a new collection\n  if (\n    typeof dbCheck != \"undefined\" &&\n    dbCheck.name === url &&\n    dbCheck.version > 0\n  )\n    v = dbCheck.version + 1;\n\n  // Modify data when storing scan data. If storing metadata, ignore this block\n  if (!meta) {\n    // Get only results with valid DCC objects\n    data = data[url] && data[url].filter(item => Object.keys(item).length > 1);\n    if (typeof data === \"undefined\" || !data.length)\n      return actions.addInfoEvent(\"Scan data processed. No bvDCC data found.\");\n  }\n\n  // Define collections without indexes.\n  const db = new zango.Db(url, v, [collName]);\n\n  const collection = db.collection(collName);\n\n  const successMsg = meta\n    ? \"Metadata successfully stored.\"\n    : \"Scan data successfully processed.\";\n\n  collection\n    .insert(data)\n    .then(() => {\n      actions.addInfoEvent(successMsg);\n      // Completes the check switch for the entire process from starting scan to the storing of data in db:\n      !meta && actions.setProcessInProgress(false);\n      db.close();\n    })\n    .catch(error => {\n      actions.addErrorEvent(\"Error processing scanned data: \" + error.message);\n      console.error(error);\n      // Completes the check switch for the entire process from starting scan to the storing of data in db:\n      !meta && actions.setProcessInProgress(false);\n      db.close();\n    });\n\n  db.on(\"blocked\", () => {\n    console.warn(\"database version cannot be upgraded\");\n    db.close();\n  });\n};\n\nexport const getDbNames = async () =>\n  window.indexedDB.databases().then(res => res.map(db => db.name));\n\nexport const getScannedMeta = async () => {\n  try {\n    const dbNames = await getDbNames();\n\n    const meta = await Promise.all(\n      dbNames.map(\n        dbName =>\n          new Promise((resolve, reject) => {\n            const db = new zango.Db(dbName, [\"metadata\"]);\n            let col = db.collection(\"metadata\");\n            col\n              .findOne()\n              .then(res => resolve({ dbName, ...res }))\n              .catch(err => reject(err));\n          })\n      )\n    );\n\n    return {\n      ok: true,\n      meta\n    };\n  } catch (error) {\n    console.warn(\"Error occurred while fetching scanned Metadata: \", error);\n    return { ok: false };\n  }\n};\n\nexport const getStoresNames = dbName => {\n  const db = new zango.Db(dbName);\n\n  return new Promise((resolve, reject) => {\n    db.open(() => {\n      resolve(db._idb.objectStoreNames);\n      db.close();\n    });\n  });\n};\n\nexport const getStoreData = async (dbName, store) => {\n  try {\n    const db = new zango.Db(dbName, [store]);\n    let col = db.collection(store);\n    const data = await col.find().toArray();\n    return { ok: true, data };\n  } catch (error) {\n    console.warn(\"Error accessing data: \", error);\n    return { ok: false, data: error };\n  }\n};\n"]},"metadata":{},"sourceType":"module"}